/*
 * Copyright (c) 2015 the original author or authors.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Simon Scholz (vogella GmbH) - initial API and implementation and initial documentation
 */

package org.eclipse.buildship.ui.view.execution;

import com.google.common.collect.ImmutableList;
import com.google.common.io.Files;
import org.eclipse.buildship.ui.UiPlugin;
import org.eclipse.buildship.ui.util.editor.EditorOpener;
import org.eclipse.core.resources.*;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.search.*;
import org.eclipse.jdt.internal.corext.util.JavaConventionsUtil;
import org.eclipse.jdt.ui.JavaUI;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.FindReplaceDocumentAdapter;
import org.eclipse.jface.text.IDocument;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.editors.text.TextFileDocumentProvider;
import org.gradle.tooling.events.OperationDescriptor;
import org.gradle.tooling.events.test.JvmTestOperationDescriptor;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;

/**
 * Opens the test source files for the given
 * {@link org.eclipse.buildship.ui.view.execution.OperationItem} test nodes. Knows how
 * to handle both Java and Groovy test source files.
 */
@SuppressWarnings("restriction")
public final class OpenTestSourceFileJob extends Job {

    private final ImmutableList<OperationItem> operationItems;

    public OpenTestSourceFileJob(List<OperationItem> operationItems) {
        super("Opening test source files");
        this.operationItems = ImmutableList.copyOf(operationItems);
    }

    @Override
    protected IStatus run(IProgressMonitor monitor) {
        for (OperationItem operationItem : this.operationItems) {
            OperationDescriptor operationDescriptor = (OperationDescriptor) operationItem.getAdapter(OperationDescriptor.class);
            if (operationDescriptor instanceof JvmTestOperationDescriptor) {
                JvmTestOperationDescriptor testOperationDescriptor = (JvmTestOperationDescriptor) operationDescriptor;
                String className = testOperationDescriptor.getClassName();
                if (className != null) {
                    String methodName = testOperationDescriptor.getMethodName();
                    searchForTestSource(monitor, className, methodName);
                }
            }
        }
        return Status.OK_STATUS;
    }

    private void searchForTestSource(IProgressMonitor monitor, final String className, final String methodName) {
        try {
            // search for Java file
            SearchEngine searchEngine = new SearchEngine();
            SearchPattern pattern = SearchPattern.createPattern(className, IJavaSearchConstants.TYPE, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_EXACT_MATCH);
            ShowTestSourceFileSearchRequester requester = new ShowTestSourceFileSearchRequester(methodName);
            searchEngine.search(pattern, new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()}, SearchEngine.createWorkspaceScope(), requester, monitor);

            // if no Java file has been found, search for Groovy file
            if (!requester.isFoundJavaTestSourceFile()) {
                IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
                workspaceRoot.accept(new ShowTestSourceFileResourceVisitor(methodName, className, Collections.singleton("groovy"))); //$NON-NLS-1$
            }
        } catch (CoreException e) {
            UiPlugin.logger().error(e.getMessage(), e);
        }
    }

    /**
     * Match the type and potentially also the method name.
     */
    private final class ShowTestSourceFileSearchRequester extends SearchRequestor {

        private final String methodName;
        private final AtomicBoolean foundJavaTestSourceFile;

        private ShowTestSourceFileSearchRequester(String methodName) {
            this.methodName = methodName;
            this.foundJavaTestSourceFile = new AtomicBoolean(false);
        }

        @Override
        public void acceptSearchMatch(SearchMatch match) throws CoreException {
            if (match.getElement() instanceof IType) {
                this.foundJavaTestSourceFile.set(true);

                IType classElement = (IType) match.getElement();
                IJavaElement methodElement = findMethod(this.methodName, classElement);
                openInEditor(methodElement != null ? methodElement : classElement);
            }
        }

        private IJavaElement findMethod(String methodName, IType type) {
            // abort search for invalid method names
            IStatus status = JavaConventionsUtil.validateMethodName(methodName, type);
            if (!status.isOK()) {
                return null;
            }

            // find parameter-less method by name
            IMethod method = type.getMethod(methodName, new String[0]);
            if (method != null && method.exists()) {
                return method;
            }

            // search textually by name (for custom runner with test methods having parameters)
            try {
                for (IMethod methodItem : type.getMethods()) {
                    if (methodItem.getElementName().equals(methodName)) {
                        return methodItem;
                    }
                }
                return null;
            } catch (JavaModelException e) {
                // ignore and treat as no method being found
                return null;
            }
        }

        private void openInEditor(final IJavaElement javaElement) {
            PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {

                @Override
                public void run() {
                    try {
                        JavaUI.openInEditor(javaElement);
                    } catch (Exception e) {
                        String message = String.format("Cannot open Java element %s in editor.", javaElement);
                        UiPlugin.logger().error(message, e);
                    }
                }
            });
        }

        private boolean isFoundJavaTestSourceFile() {
            return this.foundJavaTestSourceFile.get();
        }

    }

    /**
     * Find the file for the given class name as a resource in the workspace.
     */
    private static final class ShowTestSourceFileResourceVisitor implements IResourceVisitor {

        private static final String BIN_FOLDER_NAME = "bin"; //$NON-NLS-1$

        private final String methodName;
        private final String className;
        private final Collection<String> fileExtensions;
        private final EditorOpener editorOpener;

        public ShowTestSourceFileResourceVisitor(String methodName, String qualifiedClassName, Collection<String> fileExtensions) {
            this.methodName = methodName;
            this.className = qualifiedClassName;
            this.fileExtensions = fileExtensions;
            this.editorOpener = new EditorOpener();
        }

        @Override
        public boolean visit(final IResource resource) throws CoreException {
            if (resource.getType() == IResource.FILE && this.fileExtensions.contains(resource.getFileExtension())) {
                // map dots of qualified className to resource separators
                String classNameToPath = this.className.replaceAll(Pattern.quote("."), "/");
                String projectRelativePath = resource.getProjectRelativePath().toString();
                // ignore resources in the bin folder and find out whether the path of the resource fits
                // to the given class name
                if (!projectRelativePath.startsWith(BIN_FOLDER_NAME) && projectRelativePath.contains(classNameToPath)) {
                    Display display = PlatformUI.getWorkbench().getDisplay();
                    display.asyncExec(new Runnable() {

                        @Override
                        public void run() {
                            IWorkbenchPage activePage = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
                            @SuppressWarnings({"cast", "RedundantCast"})
                            IFile file = (IFile) resource.getAdapter(IFile.class);
                            if (file != null) {
                                try {
                                    org.eclipse.jface.text.IRegion targetRegion = getClassOrMethodRegion(file);
                                    if (targetRegion != null) {
                                        ShowTestSourceFileResourceVisitor.this.editorOpener.openAndSelect(activePage, file, targetRegion.getOffset(), targetRegion.getLength(), true, true);
                                    }
                                } catch (Exception e) {
                                    UiPlugin.logger().error(e.getMessage(), e);
                                }
                            }
                        }

                        private org.eclipse.jface.text.IRegion getClassOrMethodRegion(IFile file) throws BadLocationException, CoreException {
                            TextFileDocumentProvider textFileDocumentProvider = new TextFileDocumentProvider();
                            textFileDocumentProvider.connect(file);
                            IDocument document = textFileDocumentProvider.getDocument(file);
                            FindReplaceDocumentAdapter findReplaceDocumentAdapter = new FindReplaceDocumentAdapter(document);

                            org.eclipse.jface.text.IRegion targetRegion;
                            if (ShowTestSourceFileResourceVisitor.this.methodName != null) {
                                targetRegion = findReplaceDocumentAdapter.find(0, ShowTestSourceFileResourceVisitor.this.methodName, true, true, false, false);
                                // sometimes the method name is generated and therefore cannot be found,
                                // so we open the class here
                                if (null == targetRegion) {
                                    targetRegion = findReplaceDocumentAdapter.find(0, Files.getNameWithoutExtension(resource.getName()), true, true, false, false);
                                }
                            } else {
                                // if there is no methodName, we simply open the class
                                targetRegion = findReplaceDocumentAdapter.find(0, Files.getNameWithoutExtension(resource.getName()), true, true, false, false);
                            }

                            return targetRegion;
                        }
                    });
                    return false;
                }
            }
            return true;
        }

    }

}
